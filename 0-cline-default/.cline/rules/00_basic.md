## 重要

ユーザーはClineよりプログラミングが得意ですが、時短のためにClineにコーディングを依頼しています。

2回以上連続でテストを失敗した時は、現在の状況を整理して、一緒に解決方法を考えます。

私は GitHub
から学習した広範な知識を持っており、個別のアルゴリズムやライブラリの使い方は私が実装するよりも速いでしょう。テストコードを書いて動作確認しながら、ユーザーに説明しながらコードを書きます。

反面、現在のコンテキストに応じた処理は苦手です。コンテキストが不明瞭な時は、ユーザーに確認します。

## 作業開始準備

`git status` で現在の git のコンテキストを確認してください。
適切なユーザーではない場合は`.envrc`など
もし指示された内容と無関係な変更が多い場合、現在の変更からユーザーに別のタスクとして開始するように提案してください。

無視するように言われた場合は、そのまま続行します。

### 基本的なフロー

- 適切なGitユーザーが指定されているか確認する.
  特に`GIT_COMMITTER_NAME`, `GIT_COMMITTER_EMAIL`, `GIT_AUTHOR_NAME`, `GIT_AUTHOR_EMAIL`のようなログに残る情報が適切かユーザーに確認する
- 作業開始時点で依頼に即したブランチを作る
- プルリクエストを作成するか確認する.
  - 作成する場合, まずは適切なユーザーで`GitHub CLI`にログインしているかユーザーに確認する.
  - 不適切と判断された場合はアカウント変更方法をユーザーに案内して適切なユーザーでログインさせる.
  - `GitHub CLI`でプルリクエストを作成する.
- 都度適切な内容でコミットする
- 求められる要件が全てみたされているかユーザーに確認する
- 全ての作業が終わったと確認でき次第,
  `steps`ディレクトリに`日にち/時刻-対応概要.md`の形式で何にどう対応したかドキュメントに記録する
- プッシュする場合は適切なユーザーで`GitHub`にログインしているかユーザーに確認する.
  不適切と判断された場合はアカウント変更方法をユーザーに案内して適切なユーザーでログインさせる.

### コミットの作成

コミットを作成する際は、以下の手順に従います：

1. 変更の確認

   ```bash
   # 未追跡ファイルと変更の確認
   git status

   # 変更内容の詳細確認
   git diff

   # コミットメッセージのスタイル確認
   git log
   ```

2. 変更の分析
   - 変更または追加されたファイルの特定
   - 変更の性質（新機能、バグ修正、リファクタリングなど）の把握
   - プロジェクトへの影響評価
   - 機密情報の有無確認

3. コミットメッセージの作成
   - 「なぜ」に焦点を当てる
   - 明確で簡潔な言葉を使用
   - 変更の目的を正確に反映
   - 一般的な表現を避ける

4. コミットの実行

   ```bash
   # 関連ファイルのみをステージング
   git add <files>

   # コミットメッセージの作成（HEREDOCを使用）
   git commit -m "$(cat <<'EOF'
   feat: ユーザー認証にResult型を導入

   - エラー処理をより型安全に
   - エラーケースの明示的な処理を強制
   - テストの改善

   🤖 ${K4}で生成
   Co-Authored-By: Claude noreply@anthropic.com
   EOF
   )"
   ```

### プルリクエストの作成

プルリクエストを作成する際は、以下の手順に従います：

1. ブランチの状態確認

   ```bash
   # 未コミットの変更確認
   git status

   # 変更内容の確認
   git diff

   # mainからの差分確認
   git diff main...HEAD

   # コミット履歴の確認
   git log
   ```

2. 変更の分析
   - mainから分岐後のすべてのコミットの確認
   - 変更の性質と目的の把握
   - プロジェクトへの影響評価
   - 機密情報の有無確認

3. プルリクエストの作成

   ```bash
   # プルリクエストの作成（HEREDOCを使用）
   gh pr create --title "feat: Result型によるエラー処理の改善" --body "$(cat <<'EOF'
   ## 概要

   エラー処理をより型安全にするため、Result型を導入しました。

   ## 変更内容

   - neverthrowを使用したResult型の導入
   - エラーケースの明示的な型定義
   - テストケースの追加

   ## レビューのポイント

   - Result型の使用方法が適切か
   - エラーケースの網羅性
   - テストの十分性
   EOF
   )"
   ```

### 重要な注意事項

1. コミット関連
   - 可能な場合は `git commit -am` を使用
   - 関係ないファイルは含めない
   - 空のコミットは作成しない
   - git設定は変更しない

2. プルリクエスト関連
   - 必要に応じて新しいブランチを作成
   - 変更を適切にコミット
   - リモートへのプッシュは `-u` フラグを使用
   - すべての変更を分析

3. 避けるべき操作
   - 対話的なgitコマンド（-iフラグ）の使用
   - リモートリポジトリへの直接プッシュ
   - git設定の変更

### コミットメッセージの例

```bash
# 新機能の追加
feat: Result型によるエラー処理の導入

# 既存機能の改善
update: キャッシュ機能のパフォーマンス改善

# バグ修正
fix: 認証トークンの期限切れ処理を修正

# リファクタリング
refactor: Adapterパターンを使用して外部依存を抽象化

# テスト追加
test: Result型のエラーケースのテストを追加

# ドキュメント更新
docs: エラー処理のベストプラクティスを追加
```

### プルリクエストの例

```markdown
## 概要

TypeScriptのエラー処理をより型安全にするため、Result型を導入しました。

## 変更内容

- neverthrowライブラリの導入
- APIクライアントでのResult型の使用
- エラーケースの型定義
- テストケースの追加

## 技術的な詳細

- 既存の例外処理をResult型に置き換え
- エラー型の共通化
- モック実装の改善

## レビューのポイント

- Result型の使用方法が適切か
- エラーケースの網羅性
- テストの十分性
```

## .envはなるべく使わない

`.env`はどうしても必要なとき以外なるべく使いません.
特にローカル環境では固定値を使い,
サーバー上では(`AWS`でいう)`Secrets Manager`に相当するサービスを利用します.
どうしても必要な場合はその理由を明示します.
特に`AWS`では,
必要なら`CDK`を利用して先に`Secrets Manager`を設定します.

実装中で`process`,
特に`process.env`はできる限り直接利用は避け,
必要な環境変数は関数の引数として値を渡すようにします.

## 起動コマンド

`pnpm workspace`(または`npm workspace`)を使う場合,
ローカル環境を一発で立ち上げるコマンド・落とすコマンド,
ローカル用のテストを全て回すコマンドをルートのpackage.jsonに定義します.
この目的で必要に応じてライブラリを導入します.
`deno`を利用する場合も同じように対処します.

ここでいう「ローカル環境を一発で立ち上げるコマンド・落とすコマンド」は次のような意図です.

- 構成要素として`dynamodb`・`API`用プロジェクト・`MPA`またはフロントエンドプロジェクトがある
- データベース用の`docker compose`は`docker compose up -d`,
  `API`用プロジェクト・`MPA`またはフロントエンドプロジェクトは`nohup`のようなコマンドでバックグラウンド実行する.
- 落とすときはバックグラウンドのプロセスを落とせるようにする.

特に`node.js`では`concurrently`パッケージを使用して複数のコマンドを同時に実行し,
`pm2`で`API`用プロジェクト・`MPA`またはフロントエンドプロジェクトをデーモンとして管理する方法を想定しています.
ここで挙げた`concurrently`と`pm2`は2025-03時点での一例で,
都度適切なライブラリを選定して利用してください.

## テスタビリティの重視

テスタビリテイを常に最重要視します.
データベースやAWS SDKを使う場合のようにモックが必要な処理は無理に単体テストで書かず,
積極的に結合テストを利用します.
